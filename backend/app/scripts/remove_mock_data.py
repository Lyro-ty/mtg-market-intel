"""
Remove all mock data from the database and ensure only real data from Scryfall/MTGJSON.

This script:
1. Removes the mock marketplace (cascades to delete all related listings and price_snapshots)
2. Removes all price snapshots from non-real marketplaces (only keeps Scryfall, MTGJSON, TCGPlayer, Cardmarket, Card Kingdom)
3. Removes all listings from non-real marketplaces
4. Optionally removes synthetic price history (generated by demo scripts)

Usage:
    python -m app.scripts.remove_mock_data [--remove-synthetic] [--dry-run]
    
WARNING: This will permanently delete mock data!
"""
import argparse
import asyncio
import sys
from pathlib import Path

import structlog
from sqlalchemy import delete, select

# Setup path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from app.db.session import async_session_maker
from app.models.marketplace import Marketplace
from app.models.price_snapshot import PriceSnapshot

logger = structlog.get_logger()

# Real marketplaces that should be kept
REAL_MARKETPLACE_SLUGS = {
    "scryfall",
    "mtgjson",
    "tcgplayer",
    "cardmarket",
    "cardkingdom",
    "scg",  # Star City Games
    "coolstuffinc",
}


async def get_mock_marketplace(session) -> Marketplace | None:
    """Get the mock marketplace if it exists."""
    result = await session.execute(
        select(Marketplace).where(Marketplace.slug == "mock")
    )
    return result.scalar_one_or_none()


async def get_all_marketplaces(session) -> dict[str, Marketplace]:
    """Get all marketplaces indexed by slug."""
    result = await session.execute(select(Marketplace))
    marketplaces = result.scalars().all()
    return {mp.slug: mp for mp in marketplaces}


async def count_mock_data(session, mock_mp: Marketplace | None) -> dict:
    """Count mock data that would be deleted."""
    counts = {
        "mock_marketplace": 1 if mock_mp else 0,
        "mock_price_snapshots": 0,
        "non_real_price_snapshots": 0,
    }

    all_marketplaces = await get_all_marketplaces(session)
    real_mp_ids = {
        mp.id for slug, mp in all_marketplaces.items() if slug in REAL_MARKETPLACE_SLUGS
    }

    if mock_mp:
        # Count price snapshots from mock marketplace
        result = await session.execute(
            select(PriceSnapshot).where(PriceSnapshot.marketplace_id == mock_mp.id)
        )
        counts["mock_price_snapshots"] = len(result.scalars().all())

    # Count price snapshots from non-real marketplaces
    if real_mp_ids:
        result = await session.execute(
            select(PriceSnapshot).where(~PriceSnapshot.marketplace_id.in_(real_mp_ids))
        )
        counts["non_real_price_snapshots"] = len(result.scalars().all())

    return counts


async def remove_mock_marketplace(session, mock_mp: Marketplace | None) -> int:
    """Remove the mock marketplace (cascades to listings and price_snapshots)."""
    if not mock_mp:
        return 0
    
    await session.delete(mock_mp)
    await session.flush()
    return 1


async def remove_non_real_price_snapshots(
    session, real_mp_ids: set[int], remove_synthetic: bool = False
) -> int:
    """Remove price snapshots from non-real marketplaces."""
    if not real_mp_ids:
        # If no real marketplaces exist, don't delete anything
        return 0
    
    # Delete price snapshots from non-real marketplaces
    result = await session.execute(
        delete(PriceSnapshot).where(~PriceSnapshot.marketplace_id.in_(real_mp_ids))
    )
    await session.flush()
    return result.rowcount or 0


async def identify_synthetic_snapshots(session) -> list[tuple]:
    """
    Identify potentially synthetic price snapshots.

    Synthetic snapshots often have:
    - Very regular intervals (daily for exactly 30 days)
    - Similar patterns across many cards
    - Specific num_listings ranges (5-50, 10-200)

    This is a heuristic - we'll be conservative and only flag obvious patterns.

    Returns:
        List of (time, card_id, marketplace_id, condition, is_foil, language) tuples
        identifying synthetic snapshots by their composite primary key.
    """
    # Get all price snapshots
    result = await session.execute(select(PriceSnapshot))
    all_snapshots = result.scalars().all()

    # Group by card_id and marketplace_id
    from collections import defaultdict

    snapshots_by_card_marketplace = defaultdict(list)
    for snapshot in all_snapshots:
        key = (snapshot.card_id, snapshot.marketplace_id)
        snapshots_by_card_marketplace[key].append(snapshot)

    synthetic_keys = []

    for (card_id, marketplace_id), snapshots in snapshots_by_card_marketplace.items():
        if len(snapshots) < 20:  # Skip if too few snapshots
            continue

        # Check if snapshots are exactly daily for 30 days
        snapshots.sort(key=lambda s: s.time)
        if len(snapshots) == 31:  # 30 days + today = 31 snapshots
            # Check if intervals are approximately 1 day
            intervals = []
            for i in range(1, len(snapshots)):
                delta = snapshots[i].time - snapshots[i - 1].time
                intervals.append(delta.total_seconds() / 86400)  # Convert to days

            # If all intervals are between 0.9 and 1.1 days, it's likely synthetic
            if all(0.9 <= interval <= 1.1 for interval in intervals):
                # Check if num_listings are in the synthetic range
                num_listings_values = [
                    s.num_listings for s in snapshots if s.num_listings is not None
                ]
                if num_listings_values:
                    min_listings = min(num_listings_values)
                    max_listings = max(num_listings_values)
                    # Synthetic data often has listings between 5-60
                    if 5 <= min_listings <= 10 and 50 <= max_listings <= 250:
                        # Store composite primary key for each synthetic snapshot
                        for s in snapshots:
                            synthetic_keys.append((
                                s.time, s.card_id, s.marketplace_id,
                                s.condition, s.is_foil, s.language
                            ))

    return synthetic_keys


async def remove_synthetic_snapshots(session, synthetic_keys: list[tuple]) -> int:
    """Remove identified synthetic price snapshots by their composite keys."""
    if not synthetic_keys:
        return 0

    from sqlalchemy import and_

    total_deleted = 0

    # Delete one at a time (composite key delete)
    for key in synthetic_keys:
        time, card_id, marketplace_id, condition, is_foil, language = key
        result = await session.execute(
            delete(PriceSnapshot).where(
                and_(
                    PriceSnapshot.time == time,
                    PriceSnapshot.card_id == card_id,
                    PriceSnapshot.marketplace_id == marketplace_id,
                    PriceSnapshot.condition == condition,
                    PriceSnapshot.is_foil == is_foil,
                    PriceSnapshot.language == language,
                )
            )
        )
        total_deleted += result.rowcount or 0

        # Flush every 100 deletes
        if total_deleted % 100 == 0:
            await session.flush()

    await session.flush()
    return total_deleted


async def main():
    parser = argparse.ArgumentParser(
        description="Remove all mock data from the database"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be deleted without actually deleting",
    )
    parser.add_argument(
        "--remove-synthetic",
        action="store_true",
        help="Also remove synthetic price history (generated by demo scripts)",
    )
    args = parser.parse_args()
    
    print(f"\n{'='*60}")
    print("  Remove Mock Data")
    print(f"{'='*60}\n")
    
    if args.dry_run:
        print("  ⚠️  DRY RUN MODE - No changes will be made\n")
    else:
        print("  ⚠️  WARNING: This will permanently delete mock data!\n")
        response = input("  Type 'yes' to continue: ")
        if response.lower() != "yes":
            print("  Aborted.")
            return
    
    async with async_session_maker() as session:
        # Get mock marketplace
        mock_mp = await get_mock_marketplace(session)
        
        # Get all marketplaces
        all_marketplaces = await get_all_marketplaces(session)
        real_mp_ids = {
            mp.id
            for slug, mp in all_marketplaces.items()
            if slug in REAL_MARKETPLACE_SLUGS
        }
        
        # Count mock data
        counts = await count_mock_data(session, mock_mp)
        
        print("\n  Current state:")
        print(f"    Mock marketplace: {'Yes' if mock_mp else 'No'}")
        print(
            f"    Price snapshots from mock marketplace: {counts['mock_price_snapshots']:,}"
        )
        print(
            f"    Price snapshots from non-real marketplaces: {counts['non_real_price_snapshots']:,}"
        )

        total_to_delete = (
            counts["mock_price_snapshots"]
            + counts["non_real_price_snapshots"]
            + (1 if mock_mp else 0)
        )
        
        if total_to_delete == 0:
            print("\n  ✅ No mock data found. Database is clean!")
            return
        
        if args.remove_synthetic:
            print("\n  Identifying synthetic price snapshots...")
            synthetic_ids = await identify_synthetic_snapshots(session)
            print(f"    Found {len(synthetic_ids):,} potentially synthetic snapshots")
            total_to_delete += len(synthetic_ids)
        
        print(f"\n  Total items to delete: {total_to_delete:,}")
        
        if args.dry_run:
            print("\n  Run without --dry-run to actually delete this data.")
            return
        
        # Delete mock data
        print("\n  Deleting mock data...")

        deleted_counts = {
            "marketplace": 0,
            "price_snapshots": 0,
            "synthetic_snapshots": 0,
        }

        # Delete mock marketplace (cascades to price_snapshots)
        if mock_mp:
            deleted_counts["marketplace"] = await remove_mock_marketplace(session, mock_mp)
            print("    ✓ Deleted mock marketplace")

        # Delete price snapshots from non-real marketplaces
        deleted_counts["price_snapshots"] = await remove_non_real_price_snapshots(
            session, real_mp_ids
        )
        if deleted_counts["price_snapshots"] > 0:
            print(
                f"    ✓ Deleted {deleted_counts['price_snapshots']:,} price snapshots from non-real marketplaces"
            )
        
        # Delete synthetic snapshots if requested
        if args.remove_synthetic:
            synthetic_ids = await identify_synthetic_snapshots(session)
            deleted_counts["synthetic_snapshots"] = await remove_synthetic_snapshots(
                session, synthetic_ids
            )
            if deleted_counts["synthetic_snapshots"] > 0:
                print(
                    f"    ✓ Deleted {deleted_counts['synthetic_snapshots']:,} synthetic price snapshots"
                )
        
        # Commit all changes
        await session.commit()
        
        print(f"\n{'='*60}")
        print("  Deletion Complete!")
        print(f"{'='*60}")
        print(f"  Mock marketplace deleted: {deleted_counts['marketplace']}")
        print(f"  Price snapshots deleted: {deleted_counts['price_snapshots']:,}")
        if args.remove_synthetic:
            print(
                f"  Synthetic snapshots deleted: {deleted_counts['synthetic_snapshots']:,}"
            )
        print(f"{'='*60}\n")
        
        print("  ✅ Database now contains only real data from:")
        print("     - Scryfall")
        print("     - MTGJSON")
        print("     - TCGPlayer")
        print("     - Cardmarket")
        print("     - Card Kingdom")
        print("     - Other real marketplaces\n")


if __name__ == "__main__":
    asyncio.run(main())

