"""
Recommendation repository for trading signals and suggestions.

This repository handles storage and retrieval of trading recommendations
generated by the recommendation engine.
"""
from datetime import datetime, timedelta
from typing import Any, Sequence

from sqlalchemy import select, func, and_, or_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.recommendation import Recommendation, ActionType
from app.repositories.base import BaseRepository


class RecommendationRepository(BaseRepository[Recommendation]):
    """
    Repository for recommendation operations.

    Handles creating, querying, and managing trading recommendations.
    """

    def __init__(self, db: AsyncSession):
        super().__init__(Recommendation, db)

    async def create_recommendation(
        self,
        card_id: int,
        action: ActionType,
        confidence: float,
        *,
        reason: str | None = None,
        target_price: float | None = None,
        current_price: float | None = None,
        potential_profit: float | None = None,
        risk_level: str | None = None,
        source: str = "system",
        expires_at: datetime | None = None,
    ) -> Recommendation:
        """
        Create a new recommendation.

        Args:
            card_id: Card ID
            action: Recommended action (BUY, SELL, HOLD)
            confidence: Confidence score (0.0 to 1.0)
            reason: Human-readable reason
            target_price: Target price for the action
            current_price: Current price at recommendation time
            potential_profit: Expected profit percentage
            risk_level: Risk assessment (low, medium, high)
            source: Source of recommendation (system, user, etc.)
            expires_at: When recommendation expires

        Returns:
            Created recommendation
        """
        return await self.create(
            card_id=card_id,
            action=action,
            confidence=confidence,
            reason=reason,
            target_price=target_price,
            current_price=current_price,
            potential_profit=potential_profit,
            risk_level=risk_level,
            source=source,
            expires_at=expires_at or datetime.utcnow() + timedelta(days=7),
        )

    async def get_active(
        self,
        *,
        action: ActionType | None = None,
        min_confidence: float = 0.0,
        limit: int = 50,
    ) -> Sequence[Recommendation]:
        """
        Get active (non-expired) recommendations.

        Args:
            action: Filter by action type
            min_confidence: Minimum confidence score
            limit: Maximum results

        Returns:
            Sequence of active recommendations
        """
        now = datetime.utcnow()
        stmt = select(Recommendation).where(
            and_(
                or_(
                    Recommendation.expires_at.is_(None),
                    Recommendation.expires_at > now,
                ),
                Recommendation.confidence >= min_confidence,
            )
        )

        if action:
            stmt = stmt.where(Recommendation.action == action)

        stmt = stmt.order_by(Recommendation.confidence.desc()).limit(limit)
        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def get_for_card(
        self,
        card_id: int,
        include_expired: bool = False,
    ) -> Sequence[Recommendation]:
        """
        Get recommendations for a specific card.

        Args:
            card_id: Card ID
            include_expired: Include expired recommendations

        Returns:
            Sequence of recommendations
        """
        stmt = select(Recommendation).where(Recommendation.card_id == card_id)

        if not include_expired:
            now = datetime.utcnow()
            stmt = stmt.where(
                or_(
                    Recommendation.expires_at.is_(None),
                    Recommendation.expires_at > now,
                )
            )

        stmt = stmt.order_by(Recommendation.created_at.desc())
        result = await self.db.execute(stmt)
        return result.scalars().all()

    async def count_active(self) -> int:
        """
        Count active recommendations.

        Returns:
            Number of active recommendations
        """
        now = datetime.utcnow()
        stmt = select(func.count(Recommendation.id)).where(
            or_(
                Recommendation.expires_at.is_(None),
                Recommendation.expires_at > now,
            )
        )
        result = await self.db.execute(stmt)
        return result.scalar() or 0

    async def count_by_action(self) -> dict[str, int]:
        """
        Count recommendations by action type.

        Returns:
            Dictionary mapping action to count
        """
        now = datetime.utcnow()
        stmt = (
            select(Recommendation.action, func.count(Recommendation.id).label("count"))
            .where(
                or_(
                    Recommendation.expires_at.is_(None),
                    Recommendation.expires_at > now,
                )
            )
            .group_by(Recommendation.action)
        )
        result = await self.db.execute(stmt)
        return {row.action.value: row.count for row in result}

    async def bulk_insert(
        self,
        recommendations: list[dict[str, Any]],
    ) -> int:
        """
        Insert multiple recommendations.

        Args:
            recommendations: List of recommendation dictionaries

        Returns:
            Number of recommendations created
        """
        if not recommendations:
            return 0

        created = await self.bulk_create([
            {
                "card_id": r["card_id"],
                "action": r["action"],
                "confidence": r["confidence"],
                "reason": r.get("reason"),
                "target_price": r.get("target_price"),
                "current_price": r.get("current_price"),
                "potential_profit": r.get("potential_profit"),
                "risk_level": r.get("risk_level"),
                "source": r.get("source", "system"),
                "expires_at": r.get("expires_at", datetime.utcnow() + timedelta(days=7)),
            }
            for r in recommendations
        ])
        return len(created)

    async def expire_old(self, older_than: timedelta = timedelta(days=30)) -> int:
        """
        Expire recommendations older than a threshold.

        Args:
            older_than: Age threshold

        Returns:
            Number of recommendations expired
        """
        cutoff = datetime.utcnow() - older_than
        stmt = select(Recommendation).where(
            and_(
                Recommendation.created_at < cutoff,
                or_(
                    Recommendation.expires_at.is_(None),
                    Recommendation.expires_at > datetime.utcnow(),
                ),
            )
        )
        result = await self.db.execute(stmt)
        recommendations = result.scalars().all()

        count = 0
        for rec in recommendations:
            rec.expires_at = datetime.utcnow()
            count += 1

        await self.db.flush()
        return count

    async def get_top_opportunities(
        self,
        action: ActionType = ActionType.BUY,
        limit: int = 10,
    ) -> list[dict[str, Any]]:
        """
        Get top trading opportunities.

        Args:
            action: Action type to filter by
            limit: Maximum results

        Returns:
            List of opportunities with card details
        """
        now = datetime.utcnow()
        stmt = (
            select(Recommendation)
            .where(
                and_(
                    Recommendation.action == action,
                    or_(
                        Recommendation.expires_at.is_(None),
                        Recommendation.expires_at > now,
                    ),
                    Recommendation.confidence >= 0.7,
                )
            )
            .order_by(
                Recommendation.confidence.desc(),
                Recommendation.potential_profit.desc().nulls_last(),
            )
            .limit(limit)
        )
        result = await self.db.execute(stmt)
        recommendations = result.scalars().all()

        return [
            {
                "id": r.id,
                "card_id": r.card_id,
                "action": r.action.value,
                "confidence": r.confidence,
                "reason": r.reason,
                "target_price": r.target_price,
                "current_price": r.current_price,
                "potential_profit": r.potential_profit,
                "risk_level": r.risk_level,
                "created_at": r.created_at.isoformat() if r.created_at else None,
            }
            for r in recommendations
        ]
